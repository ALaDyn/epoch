#! /bin/sh

file=$1
success=1

build_sha1=1
embed_source=1

shift

dir=`dirname $file`
shafile=$dir/SHA1_SUM
tmp=$dir/tmp
tmp2=$dir/tmp2
tmp3=$dir/tmp3

column_width=76
continuation_lines=40

[ -d $dir ] || mkdir $dir

if [ "$1"x = "opt_dont_build_sha1"x ]; then
  build_sha1=0
  shift
fi
if [ "$1"x = "opt_dont_build_embedded_source"x ]; then
  embed_source=0
  shift
fi

if [ $build_sha1 -eq 1 ]; then
  sha=`cat $* | shasum 2>/dev/null | cut -f1 -d' '`
  if [ "$sha"x = x ]; then
    #echo shasum failed. Trying openssl.
    sha=`cat $* | openssl dgst -sha1 2>/dev/null`
    if [ "$sha"x = x ]; then
      #echo openssl failed. Trying sha1sum.
      sha=`cat $* | sha1sum 2>/dev/null | cut -f1 -d' '`
    fi
  fi
  if [ "$sha"x = x ]; then
    echo WARNING: unable to create valid sha1
  fi
fi

# Only generate new embedded source code if sha1 has changed
oldsha=1
[ -r "$shafile" ] && oldsha=`cat $shafile 2>/dev/null`
if [ "$oldsha"x = "$sha"x ]; then
  # sha is the same
  if [ $embed_source -eq 1 ]; then
    [ -f "$file" ] && embed_source=0
  fi
  rm -f $tmp $tmp2 $tmp3
  exit
else
  # sha has changed
  echo "$sha" > $shafile
fi

rm -f $tmp $tmp2 $tmp3

nlines=0

if [ $embed_source -eq 1 ]; then
  pwd=$(pwd)
  basedir=$(basename $pwd)
  file_list=""
  for f in $*; do
    newfile=${f#../}
    if [ "$newfile"x = "$f"x ]; then
      file_list="$file_list $basedir/$f"
    else
      file_list="$file_list $newfile"
    fi
  done

  tar -czf $tmp -C.. $file_list
  if [ $? -eq 0 ]; then
    # First try GNU-style wrapping options for base64
    base64 -w$column_width $tmp > $tmp2 2>/dev/null
    if [ $? -ne 0 ]; then
      # Next try BSD-style wrapping options for base64
      base64 $tmp | fold -w$column_width > $tmp2 2>/dev/null
    fi
    if [ $? -ne 0 ]; then
      #echo base64 failed. Trying mimencode.
      mimencode $tmp -o $tmp2 2>/dev/null
    fi
    if [ $? -ne 0 ]; then
      #echo mimencode failed. Trying uuencode.
      uuencode -m $tmp epoch.tgz > $tmp2 2>/dev/null
      if [ $? -eq 0 ]; then
        n=`cat $tmp2 | wc -l`
        sed -n 2,$((n-1))p $tmp2 > $tmp3
        mv $tmp3 $tmp2
      else
        false
      fi
    fi
    if [ $? -ne 0 ]; then
      #echo uuencode failed. Trying perl.
      perl -MMIME::Base64 -0777 -ne \
        'print encode_base64($_)' < $tmp > $tmp2
    fi
    if [ $? -eq 0 ]; then
      nlines=`cat $tmp2 | wc -l`
      nlines=$((nlines-1))
      success=0
    fi
  fi
fi

cat > $file <<EOF
MODULE encoded_source

  IMPLICIT NONE

  CHARACTER(LEN=*), PARAMETER :: sha1sum = '$sha'

EOF


if [ $nlines -gt 0 ]; then
  echo "  CHARACTER(LEN=*), PARAMETER :: last_line = &" >> $file
  tail -n 1 $tmp2 | sed 's/^/      '\''/; s/$/'\''/' >> $file

cat >> $file <<EOF

  CHARACTER(LEN=$column_width), DIMENSION($nlines) :: source_code

! F95 maximum line with of 132 characters, maximum of 39 continuation lines

  INTEGER :: i

EOF

IFS="
"
  i=1
  i0=1
  i1=$((i0+continuation_lines-1))
  for ln in `head -n $nlines $tmp2`; do
    if [ $i -eq $i0 ]; then
      if [ $i0 -eq $i1 ]; then
        echo "  DATA (source_code(i), i=$i0,$i1) / '$ln' /" >> $file
      else
        echo "  DATA (source_code(i), i=$i0,$i1) / '$ln', &" >> $file
      fi
    elif [ $i -ge $i1 ]; then
      echo "      '$ln' /" >> $file
      i0=$((i1+1))
      i1=$((i0+continuation_lines-1))
      [ $i1 -gt $nlines ] && i1=$nlines
    else
      echo "      '$ln', &" >> $file
    fi
    i=$((i+1))
  done

cat >> $file <<EOF

END MODULE encoded_source
EOF

else
cat >> $file <<EOF
  CHARACTER(LEN=*), PARAMETER :: last_line = ''

  CHARACTER(LEN=$column_width), DIMENSION(0) :: source_code

END MODULE encoded_source
EOF
fi

rm -f $tmp $tmp2

if [ $success -ne 0 ]; then
  echo WARNING: failed to pack source code. Restart dumps will be produced without it.
fi
