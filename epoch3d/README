EPOCH3D
-------
Epoch3D runs only in domain decomposed mode, and does not have all of the features of Epoch1D. This code will be upgraded to match the features of Epoch1D. Most of the time you will only have to change the codes input deck files and the single source file "initial_conditions.F90"

Other Makefile options
----------------------
There are various optional flags in the makefile which change how the code works. They are present as lines of the form

#NAME = -DNAME

The # symbol meaning that it is a comment. Remove the # symbol and the code will be build with this option. After changing one of these options, the code must be made clean and remade ("make clean","make"). The options are

PERPARTICLEWEIGHT - Change the code so that it allows each pseudo-particle to have an independant weight value, rather than assigning each pseudo-particle the same weight. This makes it easier to resolve regions of space with low densities.

PERPARTICLECHARGEMASS - Change the code so that each pseudo-particle has it's own charge and mass values. Although there are no ionisation routines in the code, the code has been written to allow the use of per pseudoparticle charge and mass states. Unless you are implementing ionisation, it is unlikely that you will need this option

Compiling the code
------------------
The code should compile on typing "make" in the installed directory. 
Type "make clean" to unbuild the code and remove all temporary files. This does not delete data which must be removed by hand.
Type "make visit" to build the plugin to allow the LLNL Visit(https://wci.llnl.gov/codes/visit/) to read the output files from the PIC code

Starting the code
-----------------
To run the code at the command line (on two processors), just type

mpirun -np 2 ./bin/epoch3d 

Usually a similar approach will work on a cluster (see the included epoch2d.pbs example script).

The input deck
--------------

The code expects there to be a file "input.deck" in the root directory of the code (an example is supplied) and most of the parameters are specified in the input deck. There are comments in the input deck which explain the options available.


Representation of particles in the code
---------------------------------------

The initial conditions are the area of the code which has the largest changes in it. Each particle is represented by a Fortran TYPE called Particle. The definition of TYPE(Particle) is

  TYPE :: Particle
     REAL(num), DIMENSION(3) :: Part_P         !Particle Momentum
     REAL(num) :: Part_pos                     !Particle Position
     INTEGER :: part_Species                   !Particle Species ID
#ifdef PER_PARTICLE_WEIGHT
     REAL(num) :: weight                       !Pseudoparticle weight
#endif
#ifdef PER_PARTICLE_CHARGEMASS
     REAL(num) :: charge                       !Pseudoparticle charge
     REAL(num) :: mass                         !Pseudoparticle mass
#endif
     TYPE(Particle),POINTER :: Next, Prev      !Next and previous particles in the linked list
  END TYPE Particle

The pseudoparticle weight field is only present if the code is compiled with the PERPARTICLEWEIGHT option, and the charge and mass fields are only present if the code is compiled with the PER_PARTICLE_CHARGEMASS option. The particles are linked together into a linked list using the Next and Prev fields to move to the next or previous particle in the list. So to step through the linked list, the code would look like

TYPE(Particle) :: Current
INTEGER(KIND=8) :: ipart
Current=>Head
DO WHILE(ASSOCIATED(Current))
	Current=>Current%Next
ENDDO


Note that unlike Epoch1D, Epoch3D has not been ungraded to include the abstraction of particle lists. This will change in future releases, but at present, the only way to test for reaching the end of a linked list is to test that the current pointer is associated.

Setting the initial conditions
------------------------------

To set the initial conditions, you need to modify the routine "Equilibrium" in the file "initial_conditions.F90". To set field initial conditions, you simply set the corresponding array to have the value wanted, there is a	n array simply called "x" or "y" which contains the x or y position of a given point on the grid. You should always set the arrays from -1:nx+1,-1:ny+1. The arrays are

Ex, Ey, Ez, Bx, By, Bz

To set particle properties directly you start from the routine shown in the previous section to step through all the particles and set the properties of the each particle in turn. An example, setting up an ion/electron plasma with identical thermal distributions is

INTEGER(KIND=8) :: ipart
Current=>Head
Temperature=1.0e6_num
ipart=0
DO WHILE(ASSOCIATED(Current))
	ipart=ipart+1
	!50% ion/electron plasma (ion = species1, electron=species2)
	IF (ipart .LT. npart/2) THEN
		Current%Part_Species=1
	ELSE
		Current%Part_Species=2
	ENDIF
	Current%Part_Pos(1)=(random(idum)*(x_end_local-x_start_local))+x_start_local
	Current%Part_Pos(2)=(random(idum)*(y_end_local-y_start_local))+y_start_local	
	Current%Part_P(1) = MomentumFromTemperature(species(Current%Part_Species,2),Temperature,idum)
	!No motion out of plane
	Current%Part_P(2:3)=0.0_num
	Current=>Current%Next
ENDDO

There are several things to note in this code. 

1) Note the global constant npart which is the number of particles on the current processor, the equivalent parameter for the global number of particles is npart_global. 

2) Also note the global parameters x_start_local and x_end_local which are the start and end of the domain on the current processor. The global equivalents are just x_start and x_end. Particles must be positioned to be within x_start_local and x_end_local, and similarly for y_start_local and y_end_local. Unlike Epoch1D, the code will not redistribute particles which are on the wrong processor.

4) Note the helper function "random" which generates a uniform random number between 0 and 1. The associated value idum is initially the seed for the random number generator, and should only be changed to reseed the random number generator. Many other functions make use of "random"

5) Note the helper function "MomentumFromTemperature" which returns a momentum for a particles given the particle mass, the temperature and the current state of the random number generator

6) Note the array "species" which contains properties for each species of particle in the problem. Species(ispecies,1) is the particle charge, Species(ispecies,2) is the particle mass.