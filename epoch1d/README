This version of EPOCH1D is significantly different to the releases of PIC1D which you may already have been given. This document gives a quick description of how to use the code.

The general structure is the same, and most of the time you will only have to change the codes input deck files and the single source file "initial_conditions.F90"


Compiling the code
------------------
The code should compile on typing "make" in the installed directory. 
Type "make clean" to unbuild the code and remove all temporary files. This does not delete data which must be removed by hand.
Type "make visit" to build the plugin to allow the LLNL Visit(https://wci.llnl.gov/codes/visit/) to read the output files from the PIC code


Other Makefile options
----------------------
There are various optional flags in the makefile which change how the code works. They are present as lines of the form

#NAME = -DNAME

The # symbol meaning that it is a comment. Remove the # symbol and the code will be build with this option. After changing one of these options, the code must be made clean and remade ("make clean","make"). The options are

PERPARTICLEWEIGHT - Change the code so that it allows each pseudo-particle to have an independant weight value, rather than assigning each pseudo-particle the same weight. This makes it easier to resolve regions of space with low densities.

PERPARTICLECHARGEMASS - Change the code so that each pseudo-particle has it's own charge and mass values. Although there are no ionisation routines in the code, the code has been written to allow the use of per pseudoparticle charge and mass states. Unless you are implementing ionisation, it is unlikely that you will need this option

INPUTFILE - This changes the way the input deck control functions. This will be removed once testing on the newer input deck functions is complete. Unless you have problems with the code, you should have this line uncommented.

Starting the code
-----------------
Unlike in previous versions, the code will not start unattended. When the code first runs, you are presented with the welcome message and then asked to specify the output directory. The output directory must exist and must contain the file "input.deck" which is the input deck for the current run. To start the code without user input, you have to pipe in a file which contains the name of the output directory. An example file called "deck.file" is given. To run the code at the command line (on two processors), just type

mpirun -np 2 ./bin/epoch1d < deck.file

Usually a similar approach will work on a cluster (see the included epoch1d.pbs example script). Some scheduling systems do not allow you to redirect using pipes, and implement their own approach. On these systems, look in the help files for mpirun for an option to specify "standard input" or "stdin".

The code will then start and run normally and will dump the output files into the directory that was specified at runtime.

To help with deleting data from a run while leaving input deck files behind, the script "cleandir" is provided. This script is run as

	cleandir Data
and will delete all the output files from an EPOCH run from the directory Data.

The input deck
--------------

The input deck is basically unchanged from previous versions of the code and each entry in the deck is commented individually. The only important change is the introduction of the "import" directive. The import directive is of the form

import:filename.extension

When the deck parser encounters an import directive, it opens the file "filename.extension" and continues to parse the deck unchanged. When it reaches the end of the file "filename.extension" it returns to the file it was previously parsing and continues. There is a maximum import depth of 10 (i.e. you can import a file from within an imported file, and you can import a file from an imported file from an imported file, but when there are more than 10 levels of import, the code will fail). This is demonstrated in the supplied example deck where the file "input.deck" imports four other files to split up the input deck. You do not have to use import directives and you can have a single large input.deck file if you wish.


Representation of particles in the code
---------------------------------------

The initial conditions are the area of the code which has the largest changes in it. Each particle is represented by a Fortran TYPE called Particle. The definition of TYPE(Particle) is

  TYPE :: Particle
     REAL(num), DIMENSION(3) :: Part_P         !Particle Momentum
     REAL(num) :: Part_pos                     !Particle Position
     INTEGER :: part_Species                   !Particle Species ID
#ifdef PER_PARTICLE_WEIGHT
     REAL(num) :: weight                       !Pseudoparticle weight
#endif
#ifdef PER_PARTICLE_CHARGEMASS
     REAL(num) :: charge                       !Pseudoparticle charge
     REAL(num) :: mass                         !Pseudoparticle mass
#endif
     TYPE(Particle),POINTER :: Next, Prev      !Next and previous particles in the linked list
  END TYPE Particle

The pseudoparticle weight field is only present if the code is compiled with the PERPARTICLEWEIGHT option, and the charge and mass fields are only present if the code is compiled with the PER_PARTICLE_CHARGEMASS option. The particles are linked together into a linked list using the Next and Prev fields to move to the next or previous particle in the list. So to step through the linked list, the code would look like

TYPE(Particle) :: Current
INTEGER(KIND=8) :: ipart
Current=>MainRoot%Head
DO ipart=1,MainRoot%Count
	Current=>Current%Next
ENDDO

This will visit each particle in the list once and only once. The object "MainRoot" is an example of another Fortran TYPE called ParticlePointer. The definition of TYPE(ParticlePointer) is 


  TYPE :: ParticlePointer
     TYPE(Particle),POINTER :: Head            !First particle in list
     TYPE(Particle),POINTER :: Tail            !Last particle in list
     INTEGER(KIND=8) :: Count                  !Number of particles in list
     LOGICAL :: Safe                           !Pointer is safe if the particles in it are all unambiguously linked
  END TYPE ParticlePointer

This is fairly self explanatory except for the "Safe" parameter. MainRoot is always safe, but other examples of TYPE(ParticlePointer) can be found in other places which are not. An unsafe TYPE(ParticlePointer) is normally a subset of another TYPE(ParticlePointer). The Safe flag is normally only used internally and will be documented more fully in the programmers guide.

Setting the initial conditions
------------------------------

To set the initial conditions, you need to modify the routine "Equilibrium" in the file "initial_conditions.F90". To set field initial conditions, you simply set the corresponding array to have the value wanted, there is an array simply called "x" which contains the x position of a given point on the grid. You should always set the arrays from -1:nx+1. The arrays are

Ex, Ey, Ez, Bx, By, Bz

There are two ways of setting particle initial conditions : Use the helper functions or set the particle properties directly. 

Setting particle properties directly
========================================================================================================================================================================================================================
To set particle properties directly you start from the routine shown in the previous section to step through all the particles and set the properties of the each particle in turn. An example, setting up an ion/electron plasma with identical thermal distributions is

Current=>MainRoot%Head
Temperature=1.0e6_num
DO ipart=1,MainRoot%Count
	!50% ion/electron plasma (ion = species1, electron=species2)
	IF (ipart .LT. npart/2) THEN
		Current%Part_Species=1
	ELSE
		Current%Part_Species=2
	ENDIF
	Current%Part_Pos=(random(idum)*(x_end_local-x_start_local))+x_start_local
	Current%Part_P(0) = MomentumFromTemperature(species(Current%Part_Species,2),Temperature,idum)
	!No motion out of plane
	Current%Part_P(1:2)=0.0_num
	Current=>Current%Next
ENDDO

There are several things to note in this code. 
1) Since you are manually setting the particle species, this ignores the "fraction" set in the input deck. 

2) Note the global constant npart which is the number of particles on the current processor, the equivalent parameter for the global number of particles is npart_global. 

3) Also note the global parameters x_start_local and x_end_local which are the start and end of the domain on the current processor. The global equivalents are just x_start and x_end. When running in full domain mode x_start_local=x_start on every processor and x_end_local=x_end on each processor. Where possible particles should be positioned to be within x_start_local and x_end_local, although the code will relocate particles which are positioned outside the current processor's domain.

4) Note the helper function "random" which generates a uniform random number between 0 and 1. The associated value idum is initially the seed for the random number generator, and should only be changed to reseed the random number generator. Many other functions make use of "random"

5) Note the helper function "MomentumFromTemperature" which returns a momentum for a particles given the particle mass, the temperature and the current state of the random number generator

6) Note the array "species" which contains properties for each species of particle in the problem. Species(ispecies,1) is the particle charge, Species(ispecies,2) is the particle mass.
========================================================================================================================================================================================================================

Using helper functions
========================================================================================================================================================================================================================
Using the helper functions is easier, but reduces flexibility. There are five helper routines

LoadParticles(idum, specieslists)
	INTEGER :: idum
	TYPE(ParticlePointer),DIMENSION(1:nspecies) :: specieslists

SetupParticleListByTemperature(Temperature, Direction, ParticleList, idum)
	REAL(num),DIMENSION(-1:nx_global+1) :: Temperature
	INTEGER :: Direction
	TYPE(ParticlePointer) :: ParticleList
	INTEGER :: idum

SetupParticleListByDensity(Density, ParticleList, idum)
	REAL(num),DIMENSION(-1:nx_global+1) :: Density
	TYPE(ParticlePointer) :: ParticleList
	INTEGER :: idum

SetupParticlesByTemperature(Temperature, Direction, idum)
	REAL(num),DIMENSION(-1:nx_global+1) :: Temperature
	INTEGER :: Direction
	INTEGER :: idum

SetupParticlesByDensity(Density, idum)
	REAL(num),DIMENSION(-1:nx_global+1) :: Density
	INTEGER :: idum


idum is the random number parameter already defined. Set it once at the start to seed the random number generator and then keep it constant

LoadParticles
-------------
Loads psuedo-particles uniformly in space with zero momentum and uses the "fraction" parameter in the input deck to select the number of particles of each type. The specieslists parameter returns an array of unsafe TYPE(ParticlePointer) types refering to each particle species. Using these TYPE(ParticlePointer) objects then allows you to have different temperatures for each species etc. You can use these returned particles lists in place of "MainRoot" to then alter particle properties directly on a species by species basis

SetupParticleListByTemperature
------------------------------
Temperature is a REAL(num) array which is of the same size as the global grid (-1:nx_global+1) and contains the temperature of the particles in ParticleList in all space. There is an array called x_global which contains the x position of all points from -1:nx_global+1. ParticleList is the list of particles that are to have this temperature applied to them, and can be either one of the species lists returned by LoadParticles or "MainRoot". If you specify "MainRoot" the routine acts identically to SetupParticlesByTemperature. Direction is the direction in which the particle is to have the thermal speed assigned to it, it can be any combination of the three constants

DIR_X - X direction
DIR_Y - Y direction
DIR_Z - Z direction

The constants are combined by addition, so to set momentum in X and Y, you would use 
	CALL SetupParticleListByTemperature(Temperature, DIR_X+DIR+_Y, specieslists(1), idum)

SetupParticleListByDensity
--------------------------
Density is a REAL(num) array which is of the same size as the global grid (-1:nx_global+1) and contains the density of the particles in ParticleList in all space. ParticleList is again a list of particles for the function to act on, and can either be one of the ParticleLists returned by LoadParticles or "MainRoot". If the code is compiled with the parameter "PERPARTICLEWEIGHT" then the code will keep a uniform distribution of pseudoparticles and weight the pseudoparticles to match the specified density profile. If the code is compiled without the parameter "PERPARTICLEWEIGHT" then the code will reload the pseudoparticles based on the specified density.

========================================================================================================================================================================================================================

Supplied initial conditions
---------------------------

The code is supplied with initial conditions using the helper functions which are taken from McKean et al. (ApJ364, 295-301), but without their alpha particles.
